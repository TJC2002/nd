# ND网盘 - 文件上传协议与存储方案

## 1. 上传协议概述

### 1.1 核心功能
- **分片上传**：大文件分块上传，提升传输稳定性和速度
- **秒传**：基于文件哈希值的快速上传
- **断点续传**：支持网络中断后继续上传，无需重新开始
- **并发上传**：多分片并行上传，提高传输效率
- **上传进度**：实时显示上传进度和速度

### 1.2 技术选型
- **前端**：XMLHttpRequest/Fetch API + FormData
- **后端**：Spring Boot + Apache Commons FileUpload
- **存储**：本地存储 + 云存储（OSS/MinIO）
- **缓存**：Redis（存储上传状态、文件哈希值）

## 2. 上传流程设计

### 2.1 整体流程
1. **文件预处理**：前端计算文件哈希值，获取文件基本信息
2. **秒传检查**：前端发送哈希值到后端，检查文件是否已存在
3. **上传初始化**：后端创建上传任务，返回上传参数
4. **分片上传**：前端分块上传文件，后端接收并存储分片
5. **分片合并**：所有分片上传完成后，后端合并分片成完整文件
6. **元数据保存**：后端更新文件元数据，返回文件信息
7. **上传完成**：前端显示上传成功，更新文件列表

### 2.2 详细步骤

#### 2.2.1 1. 文件预处理
- **前端**：
  1. 获取文件信息（文件名、大小、类型）
  2. 使用Web Worker计算文件MD5/SHA256哈希值（避免阻塞主线程）
  3. 确定分片大小（默认4MB，可根据文件大小调整）
  4. 计算分片数量

#### 2.2.2 2. 秒传检查
- **前端**：发送文件哈希值和基本信息到后端
- **后端**：
  1. 接收文件哈希值
  2. 查询数据库中是否存在相同哈希值的文件
  3. 若存在，返回秒传成功，跳过后续上传步骤
  4. 若不存在，返回需要上传，进入下一步

#### 2.2.3 3. 上传初始化
- **前端**：发送上传初始化请求，包含文件信息和分片信息
- **后端**：
  1. 验证用户权限和存储空间
  2. 创建上传任务记录
  3. 分配存储路径
  4. 返回上传ID、分片大小、存储节点信息

#### 2.2.4 4. 分片上传
- **前端**：
  1. 按顺序或并发上传分片
  2. 每个分片包含上传ID、分片索引、分片数据
  3. 实时显示上传进度和速度
  4. 处理上传失败，自动重试
- **后端**：
  1. 接收分片数据
  2. 验证分片完整性
  3. 临时存储分片文件
  4. 记录已上传分片信息

#### 2.2.5 5. 分片合并
- **前端**：所有分片上传完成后，发送合并请求
- **后端**：
  1. 验证所有分片是否上传完成
  2. 按顺序合并分片成完整文件
  3. 计算合并后文件的哈希值，验证完整性
  4. 将文件移动到最终存储位置
  5. 清理临时分片文件

#### 2.2.6 6. 元数据保存
- **后端**：
  1. 生成文件唯一标识
  2. 存储文件元数据（文件名、大小、哈希值、存储位置等）
  3. 更新用户存储空间使用情况
  4. 返回文件完整信息

#### 2.2.7 7. 上传完成
- **前端**：
  1. 接收上传成功响应
  2. 更新文件列表
  3. 显示上传完成通知

## 3. API接口设计

### 3.1 上传相关接口

| 接口 | 方法 | 路径 | 功能描述 | 请求体 (JSON) | 成功响应 (200 OK) |
|------|------|------|----------|--------------|-------------------|
| 秒传检查 | POST | /api/files/check | 检查文件是否已存在 | `{"hash": "文件哈希值", "name": "文件名", "size": 文件大小, "type": "文件类型"}` | 存在: `{"exist": true, "fileId": "文件ID"}`<br>不存在: `{"exist": false}` |
| 上传初始化 | POST | /api/files/upload/init | 初始化上传任务 | `{"name": "文件名", "size": 文件大小, "type": "文件类型", "hash": "文件哈希值", "chunkSize": 分片大小, "totalChunks": 总分片数}` | `{"uploadId": "上传ID", "chunkSize": 分片大小, "storageNode": "存储节点信息"}` |
| 分片上传 | POST | /api/files/upload/chunk | 上传文件分片 | FormData: `uploadId`, `chunkIndex`, `chunkData` | `{"success": true, "chunkIndex": 分片索引}` |
| 上传完成 | POST | /api/files/upload/complete | 完成上传，合并分片 | `{"uploadId": "上传ID", "fileName": "文件名", "hash": "文件哈希值"}` | `{"success": true, "fileId": "文件ID", "fileInfo": {...}}` |
| 上传状态 | GET | /api/files/upload/status/{uploadId} | 获取上传状态 | N/A | `{"uploadId": "上传ID", "fileName": "文件名", "totalSize": 文件大小, "uploadedSize": 已上传大小, "chunks": [{"index": 0, "status": "completed"}, ...]}` |
| 取消上传 | POST | /api/files/upload/cancel/{uploadId} | 取消上传任务 | N/A | `{"success": true, "message": "上传已取消"}` |

### 3.2 下载相关接口

| 接口 | 方法 | 路径 | 功能描述 | 请求体 (JSON) | 成功响应 (200 OK) |
|------|------|------|----------|--------------|-------------------|
| 文件下载 | GET | /api/files/{fileId}/download | 下载文件 | N/A | 文件流 |
| 断点下载 | GET | /api/files/{fileId}/download | 断点续传下载 | Range头: `bytes=start-end` | 206 Partial Content + 文件流 |
| 获取文件信息 | GET | /api/files/{fileId}/info | 获取文件详细信息 | N/A | `{"id": "文件ID", "name": "文件名", "size": 文件大小, "type": "文件类型", "hash": "文件哈希值", "uploadTime": "上传时间", "storagePath": "存储路径"}` |

## 4. 前端实现

### 4.1 核心功能实现

#### 4.1.1 文件哈希计算
- 使用Web Worker计算文件哈希值，避免阻塞主线程
- 支持MD5/SHA256等哈希算法
- 大文件哈希计算优化

#### 4.1.2 分片上传
- 分块上传文件，每块大小可配置（默认4MB）
- 并发上传多个分片，提高上传速度
- 实时显示上传进度和速度
- 网络错误自动重试机制

#### 4.1.3 断点续传
- 支持网络中断后继续上传
- 自动检测未上传的分片
- 只上传未完成的分片，节省时间和带宽

### 4.2 前端优化
- **Web Worker**：使用Web Worker计算文件哈希值，避免阻塞主线程
- **并发控制**：限制并发上传数量，避免浏览器崩溃
- **重试机制**：网络错误时自动重试，提高上传成功率
- **进度显示**：使用ProgressEvent实时显示上传进度
- **用户体验**：
  - 拖拽上传
  - 批量上传
  - 上传队列管理
  - 暂停/继续上传

## 5. 后端实现

### 5.1 核心组件
- **上传服务**：处理上传请求，管理上传状态
- **存储服务**：管理文件存储，适配不同存储介质
- **文件服务**：管理文件元数据
- **哈希服务**：计算和验证文件哈希值

### 5.2 分片上传实现
- 接收上传初始化请求，创建上传任务
- 存储上传任务信息到Redis
- 接收分片数据，验证完整性
- 临时存储分片文件
- 记录已上传分片信息
- 合并分片成完整文件
- 验证文件完整性
- 清理临时文件

### 5.3 存储服务实现
- 管理不同存储介质的文件存储
- 提供统一的存储接口
- 支持本地存储和云存储
- 根据存储策略选择合适的存储介质
- 管理临时上传目录
- 处理文件的保存和获取

### 5.4 秒传实现
- 根据文件哈希值查询文件是否已存在
- 若文件已存在，直接返回文件ID，实现秒传
- 若文件不存在，返回需要上传的响应

## 6. 存储介质适配

### 6.1 本地存储
- **优点**：部署简单，成本低，访问速度快
- **缺点**：存储空间有限，扩展性差
- **配置**：
  - 基础路径：`/data/storage`
  - 目录结构：`{basePath}/files/{hash[0-1]}/{hash[2-3]}/{hash}`
  - 临时目录：`{basePath}/temp/{uploadId}`

### 6.2 阿里云OSS
- **优点**：存储容量大，扩展性强，可靠性高
- **缺点**：成本较高，访问速度受网络影响
- **配置**：
  - Endpoint：OSS服务端点
  - Bucket：存储桶名称
  - AccessKey/SecretKey：访问凭证
  - 存储路径：`files/{hash[0-1]}/{hash[2-3]}/{hash}`

### 6.3 MinIO
- **优点**：开源，兼容S3协议，部署灵活
- **缺点**：需要自行维护
- **配置**：
  - Endpoint：MinIO服务地址
  - Bucket：存储桶名称
  - AccessKey/SecretKey：访问凭证
  - 存储路径：`files/{hash[0-1]}/{hash[2-3]}/{hash}`

### 6.4 存储策略
- **大文件**：存储在云存储（OSS/MinIO）
- **小文件**：存储在本地
- **热点文件**：缓存到本地，提高访问速度
- **多存储节点**：支持横向扩展，提高存储容量和可靠性

## 7. 性能优化

### 7.1 前端优化
- **分片大小**：根据网络环境和文件大小调整分片大小（建议4MB-10MB）
- **并发数**：根据浏览器和网络环境调整并发上传数（建议3-5个）
- **缓存**：缓存文件哈希值，避免重复计算
- **预上传**：预测用户可能上传的文件，提前计算哈希值

### 7.2 后端优化
- **异步处理**：使用异步IO处理文件上传，提高并发能力
- **缓存**：使用Redis缓存上传状态和文件哈希值
- **数据库优化**：使用批量插入和索引优化，提高元数据存储速度
- **存储优化**：
  - 使用SSD存储热点文件
  - 定期清理临时文件
  - 压缩存储小文件

### 7.3 监控与告警
- **上传成功率**：监控上传成功率，及时发现问题
- **上传速度**：监控上传速度，优化存储节点
- **存储使用**：监控存储使用情况，及时扩容

## 8. 安全性考虑

### 8.1 前端安全
- **文件类型验证**：限制上传文件类型，防止恶意文件
- **文件大小限制**：限制单个文件大小，防止存储耗尽
- **CSRF保护**：使用CSRF Token保护上传接口
- **XSS防护**：对文件名等用户输入进行转义

### 8.2 后端安全
- **身份验证**：验证用户身份，防止未授权上传
- **权限控制**：验证用户上传权限，防止越权操作
- **文件类型验证**：后端再次验证文件类型，防止恶意文件
- **存储安全**：
  - 防止路径遍历攻击
- **网络安全**：
  - 使用HTTPS传输文件

## 9. 测试与部署

### 9.1 测试策略
- **单元测试**：测试上传服务、存储服务等核心组件
- **集成测试**：测试完整上传流程
- **性能测试**：测试大文件上传、并发上传性能
- **可靠性测试**：测试网络中断、服务器重启等场景下的上传可靠性
- **兼容性测试**：测试不同浏览器、操作系统、网络环境下的上传功能

### 9.2 部署建议
- **开发环境**：本地存储，简化配置
- **测试环境**：模拟生产环境，使用本地存储 + 测试用云存储
- **生产环境**：
  - 多存储节点部署
  - 负载均衡
  - 定期备份
  - 监控系统

## 10. 总结

本上传协议设计通过分片上传、秒传、断点续传等技术，提供了一个高效、可靠、用户友好的文件上传解决方案。前端实现了流畅的用户体验，后端实现了灵活的存储策略，支持多种存储介质。

该方案不仅满足了ND网盘的需求，也为未来的功能扩展和性能优化做好了准备。通过合理的架构设计和技术选型，确保了系统的可扩展性和可靠性。